<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[vue中视图不更新的问题]]></title>
      <url>%2F2017%2F04%2F20%2Fvue%E4%B8%AD%E5%93%8D%E5%BA%94%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E6%98%BE%E7%A4%BA-%E9%9A%90%E8%97%8Fdiv%2F</url>
      <content type="text"><![CDATA[vue是基于数据驱动的前端框架，使用的时候得注意将思维从老早的jQuery之类的事件驱动转到数据驱动上来。比如下面的示例，想要通过点击事件，切换div的显示/隐藏，从而使得两个div交替显示。不应该往操作DOM方向去想，站在vue数据驱动的角度看，想要视图更新，只能从数据着手。这时候可能会有个坑——数据改变了，视图却并没更新。示例： &lt;div class="cont" v-on:click="toggle(index)" > &lt;div class="content" v-if="show_cont[index]"> ... &lt;/div> &lt;div class="summary" v-if="!show_cont[index]"> ... &lt;/div> &lt;/div> 给.cont绑定一个toggle事件，点击时改变show_cont[index]的值(布尔类型，0/1互相切换)，通过v-if判断是否显示。 但是会发现已经改变了值，页面数据不更新，只能在控制台看到值在变化。我理解的是vue的生命周期的问题。mounted挂载完成之后，需要检测数组的变化才能触发视图更新。 // 因为JavaScript 有限制，Vue.js 不能检测到下面数组变化： // 1. 直接用索引设置元素，如 vm.items[0] = {}； // 2. 修改数据的长度，如 vm.items.length = 0。 遇到类似的情况可以通过vue变异方法，可以确保会触发视图更新 toggle: function(i){ this.show_cont.splice(i, 1, !this.show_cont[i]) }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[锤子官网的3D效果轮播图的实现]]></title>
      <url>%2F2017%2F04%2F20%2F%E9%94%A4%E5%AD%90%E5%AE%98%E7%BD%91%E7%9A%843D%E6%95%88%E6%9E%9C%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[看到锤子官网的3d轮播图的效果，觉得还挺酷炫，便决定把它做出来。基本的思路很简单：首先肯定要用到css3的3D转换，转换的值需要采集——先在图片区域内建立一个坐标系，以图片的中心为原点——获取e.pageX和e.pageY的值，然后分别减去图片宽、高的一半就能确定原点了。然后监听鼠标在坐标系内移动，确定鼠标相对于坐标系的坐标。通过这个坐标的值(x,y)，经过自定义的运算得到一个值，传给css中transform的rotateX和rotateY。 $(function(){ //轮播图 var fade_conf= { index : 0, times : 3000, el : ".carousel .carousel-inner .item", toggle_el : ".carousel .carousel-control .item-dot" } function fadeIn(){ var $length = $(fade_conf.el).length; for (var i = 0; i < $length; i++) { var $this = $(fade_conf.el).eq(i); var $index = $this.index(); if (i==fade_conf.index) { $this.addClass('active'); $(fade_conf.toggle_el).eq($index).addClass('active'); }else{ $this.removeClass('active'); $(fade_conf.toggle_el).eq($index).removeClass('active') } } fade_conf.index++; if (fade_conf.index==$length) { fade_conf.index = 0; } } setInterval(function(){ fadeIn() },fade_conf.times) //3D效果 var pos_conf = { orig_x : $('.carousel').offset().left+parseInt($('.carousel').css('width'))/2, orig_y : $('.carousel').offset().top+parseInt($('.carousel').css('height'))/2, offsetX : 15, offsetY : 60 } $('.carousel').mousemove(function(e) { var x = pos_conf.orig_x - e.pageX; var y = pos_conf.orig_y - e.pageY; $(this).css('transition',''); $(this).css({transform: "rotateX("+y/pos_conf.offsetX+"deg) rotateY("+x/pos_conf.offsetY+"deg)"}) }); $('.carousel').mouseleave(function(){ $(this).css({transform: "rotateX("+0+"deg) rotateY("+0+"deg)",transition:"transform "+.9+"s ease"}) }) $('.panel').find('.dot li').hover(function(){ $(this).closest('.item').find('.dot li').removeClass('active'); $(this).addClass('active'); $(this).closest('.item').find('.img_cover img').css('z-index','1'); $(this).closest('.item').find('.img_cover img').eq($(this).index()).css('z-index','2'); }) $(fade_conf.toggle_el).mouseover(function(){ var $index = $(this).index(); $(fade_conf.toggle_el).removeClass('active') $(this).addClass('active'); $(fade_conf.el).removeClass('active'); $(fade_conf.el).eq($index).addClass('active'); fade_conf.index = $index; }) }) 写完觉得很有趣，又写了一个背景帧动画的效果——每次改变一定量的背景图片position的值 function bgFrame(el,x){ for (var i = 0; i &lt; 5; i++) { (function(i) { setTimeout(function() { i = (i-4)*x; $(el).css(&quot;background-position&quot;,&quot;0 &quot;+i+&quot;px&quot;); }, i*100); })(i); } } 用了一个简单的闭包实现帧动画效果的函数。函数中两个参数分别是控制帧动画的元素选择器，和每次需要移动的像素。因为setTimeout是异步的，所以在循环里写了一个立即执行函数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用nodejs解决http403禁止访问]]></title>
      <url>%2F2017%2F04%2F20%2F%E7%94%A8nodejs%E8%A7%A3%E5%86%B3http403%E7%A6%81%E6%AD%A2%E8%AE%BF%E9%97%AE%2F</url>
      <content type="text"><![CDATA[有一些开放的API，使用时可能会遇到这样的情况：直接访问连接，能够打开图片。但在项目里直接引用url，会出现403错误。是因为服务器做了一些限制。绕过限制有一个办法就是使用本地代理。可以用nodejs起一个简单的本地服务解决这个问题。需要用到request模块： $ npm install request var request = require(&quot;request&quot;); var url = require(&apos;url&apos;); var http = require(&apos;http&apos;); http.createServer(function (req, res) { try { var params = url.parse(req.url, true).query; request(params.url).pipe(res) } catch(err) { console.log(err) } }).listen(3000); console.log(&apos;Server running at http://127.0.0.1:3000/&apos;); 在项目中引用url时前面加上localhost:3000/?id={url} &nbsp;&nbsp;&nbsp;&nbsp;// {url}为需要引用的真实url。这时项目是在访问localhost:3000,不会有权限问题。在访问localhost:3000/?id={url}时，会经过上面的代码将请求的url解析并存在params变量中，params.url就是项目引用的真实url。然后request(params.url)，相当于本地直接打开{url}链接，通过pipe方法将数据返回回来，就绕过了服务器设置的权限拿到数据。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[display:none与visible:hidden的区别]]></title>
      <url>%2F2017%2F04%2F20%2Fdisplay-none%E4%B8%8Evisible-hidden%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[#test1:hover { display: none; } #test2:hover { visibility: hidden; } #test3:hover { opacity: 0; } #demo1p { visibility: hidden; transition: 3s; } #demo1:hover #demo1p{ visibility: visible; } opacity在三者中显然差别很大，opacity只是对元素做一个透明度的处理。不需多讲。display:none和visibility:hidden在一开始接触时可能会有一些容易混淆的地方。display:none和visibility:hidden都是把网页上某个元素隐藏起来。但从本质上看两者完全不同。示例： display: none visibility: hiddenopacity: 0 display:none是讲元素完全移除，这里的完全移除是指浏览器在渲染时不再保留此元素的位置。而visibility:hidden在隐藏元素时，移除的没那么彻底，它会告诉浏览器，这个位置我已经占了，你的给我保留这个位置。所以在上面的示例中，我设置的是鼠标移到第一个div上时，将其display变为none。明显移到第一个div时，它在不断的跳动。这并不是什么bug。因为当鼠标hover时，display变为none了，浏览器中不再保留元素的位置，这就相当于鼠标移出了。display又变回block，重新回到原位置，再次触发hover事件所以看到它在不断跳动。移到第二个div上时，将其visibility变为hidden。有时似乎它也在闪动。试着讲鼠标直接移上这个div保持不动，它就不会闪动。visibility: hidden只是告诉浏览器预留了一个位置，并不是说它真的还在这里。所以触发hover事件后鼠标移动了，相当于移出了这个div。在第三个div里，绑定hover设置opacity: 0。只有鼠标真的移出范围，它才又显示出来。因为它一直都在这儿。这是display:none和visibility:hidden基本的区别。从深一点的层次看，我所理解的display:none和visibility:hidden有三个方面的区别：1 空间占据2 回流与渲染3 株连性前面已经说完空间第一点的区别。回流与渲染：由于display:none会移除元素的位置，可由其他元素占用。必然会导致reflow和repaint(回流与重绘)。而visibility:hidden则没有这个影响前端性能的问题。至于第三点，display:none和visibility:hidden都会导致其子元素一同隐藏。区别是visibility:hidden的子元素可以通过设置visibility:visible显示出来，而display:none的子元素永远隐藏了，只有父元素消除display:none才能显示。我想由于display:none抹去了父元素的位置，所以逻辑上想，子元素没地方待了。而visibility:hidden的父元素是预留了位置的，其子元素可以有地方待，所以可以显示出来。还有我们常用的transtion。这是css3带来的一个非常cool的属性。但是有时可能发现为何设置了transtion，却做不到淡入淡出的渐变效果呢？因为很遗憾，display:none不支持也不可能支持transtion。可以把它想象成布尔类型。要么显示要么隐藏，没有其他值，所以在转变时没有其他状态。visibility似乎也是这样，因为visibility的值只有visibile/hidden/collapse。但其实visibility是离散步骤，在0到1数字范围之内，0表示“隐藏”，1表示“完全显示”，大于0就能显示，但和完全显示有区别。 鼠标移到这visibility:visibile设置css： visibility: hidden;transition: 3s;可以发现鼠标移上时，div立即显示,没有延迟。但鼠标移开时，会3s后消失。有一个细节:当鼠标移上时立即移出，div也立即隐藏了。当鼠标移上1s后移出，div在1s后隐藏。当鼠标移上超出3s后移出，div符合css的设置，在3s后隐藏。因为前面说过visibility的值相当于0~1之间，但大于0就显示了，等于1时完全显示。这里大于0显示在视觉上和完全显示没什么区别。但实际上还是有区别的。鼠标移上时，div只是看上去是立即显示，可以想象成它的值还是在0~1之间在增加。3s才增加到1。没增加到1时鼠标移出，就从当前的值开始减小。所以这时候div隐藏的时间是从当前值减为0的时间。这些其实并不那么重要，需求最多的应该是淡入淡出，只要知道这时候我们只能通过设置opacity才能实现渐变效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World!]]></title>
      <url>%2F2017%2F04%2F20%2Fhelloworld%2F</url>
      <content type="text"><![CDATA[你好，欢迎来到我的个人技术博客。]]></content>
    </entry>

    
  
  
</search>
